<!DOCTYPE html>
<meta charset="utf-8">
<title>Zoom + Pan</title>
<style>
    .overlay {
        fill: none;
        pointer-events: all;
    }
    body{
        margin:0;
        padding:0;
    }
</style>

<body>
    <!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
    <script src="./lib/d3.min.js" charset="utf-8"></script>
    <script src="./lib/jLouvain.js"></script>
    <script>
        var width = 550,
            height = 550,
            canvas = d3.select("body").append("canvas")
                        .attr("width", width)
                        .attr("height", height)
                        .node(),
            context = canvas.getContext("2d"),
            nodes,
            links,
            hoverNode = '',
            ori_graph;

        var color = d3.scaleOrdinal(d3.schemeCategory20);

        var simulation = d3.forceSimulation()
                            .force("link",d3.forceLink().id(function(d){return d.id;}).distance(function(d){
                                // console.log(d);
                                return (d.source.children||d.target.children)?80:30
                            }))
                            .force("charge",d3.forceManyBody())
                            .force("center",d3.forceCenter(width/2,height/2));



        var x = d3.scaleLinear()
            .domain([0, width])
            .range([0, width]);

        var y = d3.scaleLinear()
            .domain([0, height])
            .range([height, 0]);
        var newScaleX = x.copy(),
            newScaleY = y.copy();

        canvas.addEventListener("mousemove",mousemove_hoveron);
        canvas.addEventListener("mouseout",mouseout_hoverout);

        // d3.json("./graph.json",function(data1){
        //     console.log(data1);
        // })
        d3.json("./data/small_graph.json",function(graph){
            // var graph = statistic(data)
            // var graph = data["2013"];
            ori_graph = graph;
            nodes = graph.nodes,
            links = graph.links;
            commu_detect();
            console.log(nodes.length);
            var n_graph = getMetaGraph(graph);
            nodes = n_graph.nodes
            links = n_graph.links

            var metaNodes = nodes;

            // for(let mnode of metaNodes){
            //     if(mnode.children){
            //
            //         var t_nodes = mnode.children,
            //             t_links = [],
            //             ids = {};
            //         t_nodes.forEach(n=>{
            //             var id = n.id||n.name;
            //             ids[id] = 1;
            //         })
            //         // console.log(ids);
            //         graph.links.forEach(l=>{
            //             // console.log(l.source,l.target);
            //             // var id = l.source.id||l.source.name?;
            //             if(ids[l.source.id] && ids[l.target.id]){
            //                 // console.log(true);
            //                 t_links.push(l);
            //             }
            //         })
            //         // console.log(t_links);
            //     }
            //     layout(t_nodes,t_links);
            // }
            simulation.nodes(nodes)
                      .on("tick",ticked);
            simulation.force("link")
                     .links(links);

        })

        function layout(nodes,links){
            var simulation = d3.forceSimulation()
                                .force("link",d3.forceLink().id(function(d){return d.id||d.name;}).distance(function(d){
                                    return (d.source.children||d.target.children)?80:10
                                }))
                                .force("charge",d3.forceManyBody())
                                .force("center",d3.forceCenter(width/2,height/2));
            simulation.nodes(nodes)
                      .on("tick",ticked);
            simulation.force("link")
                     .links(links);
        }



        // d3.json("./graph.json",function(data){
        //     var graph = statistic(data)
        //     // var graph = data["2013"];
        //     nodes = graph.nodes,
        //     links = graph.links;
        //     commu_detect();
        //     graph = getMetaGraph(graph);
        //     nodes = graph.nodes
        //     links = graph.links
        //     simulation.nodes(nodes)
        //               .on("tick",ticked);
        //     simulation.force("link")
        //              .links(links);
        //
        // })
        function ticked(){
            console.log(true);
            draw();
        }



        var zoom = d3.zoom().scaleExtent([0.2, 8]).on("zoom", zoom);

        d3.select(canvas)
            // .call(d3.drag()
            //         .container(canvas)
            //         .subject(dragsubject)
            //         .on("start", dragstarted)
            //         .on("drag", dragged)
            //         .on("end", dragended))
            .call(zoom);





        // draw();

        function zoom() {

            // context.save();
            context.clearRect(0, 0, width, height);
            newScaleX = d3.event.transform.rescaleX(x);
            newScaleY = d3.event.transform.rescaleY(y);
            draw();
            // context.restore();
        }
        // function dragsubject() {
        //     return simulation.find(d3.event.x, d3.event.y);
        // }
        //
        // function dragstarted() {
        //     if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        //     d3.event.subject.fx = d3.event.subject.x;
        //     d3.event.subject.fy = d3.event.subject.y;
        // }
        //
        // function dragged() {
        //     d3.event.subject.fx = d3.event.x;
        //     d3.event.subject.fy = d3.event.y;
        // }
        //
        // function dragended() {
        //     if (!d3.event.active) simulation.alphaTarget(0);
        //     d3.event.subject.fx = null;
        //     d3.event.subject.fy = null;
        // }


        function draw() {
            context.clearRect(0,0,width,height);
            drawBackground()
            drawLinks();
            drawNodes();
            // drawTooltip(hoverNode);
        }
        function drawNodes(){
            // var n = nodes.length;
            for(let [i,n] of nodes.entries()){

                context.beginPath();
                // console.log(n);
                var cx = newScaleX(n.x)||0,
                    cy = newScaleY(n.y)||0,
                    r = 4;
                // console.log(cx,cy,r);
                var grad  = context.createRadialGradient(cx,cy,0,cx,cy,r)
                grad.addColorStop(0,"white")
                grad.addColorStop(1,color(i))
                context.fillStyle = grad;


                if(n.hoveron == true){
                    r = r*1.5;
                    context.lineWidth = 3;
                    context.strokeStyle = "white"

                }
                context.arc(cx, cy, r, 0, 2 * Math.PI);
                context.fill();
                if(n.hoveron == true){
                    context.stroke();
                }
                context.closePath()


            }
        }
        function drawTooltip(hoverNode){
            if(hoverNode!=""){
                context.beginPath()
                context.strokeStyle = "lightgrey"
                context.font = 'bold 20px consolas';
                context.textAlign = 'left';
                context.textBaseline = 'top';
                context.fillStyle="none";
                context.strokeText("hello", newScaleX(hoverNode.x)+15,newScaleY(hoverNode.y)-15);
                context.closePath()
            }
        }

        function drawBackground(){
            context.beginPath()
            context.fillStyle="black";
            context.fillRect(0,0,width,height);
            context.closePath();
        }
        function drawLinks(){
            for(let l of links){
                var source = l.source,
                    target = l.target;
                context.beginPath()
                context.strokeStyle = 'rgba(201, 199, 199,0.3)'
                context.lineWidth = Math.sqrt(l.weight)
                context.moveTo(newScaleX(source.x),newScaleY(source.y))
                context.lineTo(newScaleX(target.x),newScaleY(target.y));
                context.stroke();
            }
        }
        function commu_detect(){
            var id_index = {};
            var community = jLouvain().nodes(this.nodes.map((d, i) => {
                var key = d.id||d.name
                id_index[key] = i;
                return i;
            })).edges(this.links.map(l => {
                return {
                    weight: l.weight || l.value,
                    source: id_index[l.source],
                    target: id_index[l.target]
                };
            }));
            var community_assignment_result = community();

            var max_community_number = 0;
            this.nodes.forEach((d, i) => {
                d.community = community_assignment_result[i];
                max_community_number = max_community_number < community_assignment_result[i] ? community_assignment_result[i] : max_community_number;
            })
            console.log(max_community_number);
        }

        function mousemove_hoveron(e){
            var x = e.pageX,
                y = e.pageY;
            nodes.forEach(n=>{
                var r = 2.5+Math.sqrt(n.children.length);
                if(Math.pow(x-newScaleX(n.x),2)+Math.pow(y-newScaleY(n.y),2)<=r*r){
                    n.hoveron = true;
                    hoverNode = n;
                    console.log(true);
                }else{
                    n.hoveron = false;
                    // console.log(false);
                }
            })
            draw();
        }
        function mouseout_hoverout(e){
            hoverNode = '';
            draw();
        }
        function getMetaGraph(graph){
            var nodes = graph.nodes,
                links = graph.links;

            var nodeById = d3.map(nodes,function(d){return d.id || d.name});
            var metaNodes = {

            },
            metaLinks = [];
            links.forEach(l=>{
                if(typeof l.source !='object') l.source = nodeById.get(l.source);
                if(typeof l.target !='object') l.target = nodeById.get(l.target);
            })
            nodes.forEach(n=>{
                if(metaNodes[n.community]==undefined){
                    metaNodes[n.community]=[]
                }
                metaNodes[n.community].push(n);
            })
            for(let l of links){
                var s_id = l.source.community,
                    d_id = l.target.community;
                if(s_id==d_id) continue;
                if(metaLinks.length == 0) {
                    metaLinks.push({
                        source:s_id,
                        target:d_id,
                        weight:1
                    });
                    continue;
                }
                var isExsit = false;
                for(let ml of metaLinks){
                    if((ml.source == s_id && ml.target==d_id) ||(ml.target == s_id && ml.source==d_id)){
                        ml.weight++;
                        isExsit = true
                        break;
                    }
                }
                if(!isExsit){
                    metaLinks.push({
                        source:s_id,
                        target:d_id,
                        weight:1
                    });
                }
            }
            metaNodes = Object.keys(metaNodes).map(k=>{
                return {
                    group:k,
                    children:metaNodes[k]
                }
            });
            var nodeByGroupId = d3.map(metaNodes,function(d){return d.group})
            for(let ml of metaLinks){
                if(typeof ml.source !='object') ml.source = nodeByGroupId.get(ml.source);
                if(typeof ml.target !='object') ml.target = nodeByGroupId.get(ml.target);
            }

            // console.log(metaNodes);
            // console.log(metaLinks);
            return {
                nodes:metaNodes,
                links:metaLinks
            }
        }

        // 统计
        function statistic(graph){
            var nodes,links;
            var nodeName = {},
                allNodes = [],
                allLinks = [];

            for(let t in graph){
                if(t=="2014" || t=="2015"){
                    nodes = graph[t].nodes;
                    links = graph[t].links;
                    for(let n of nodes){
                        if(!nodeName[n.name]){
                            nodeName[n.name] = 1;
                        }
                    }
                    for(let l of links){
                        if(allLinks.length==0){
                            allLinks.push(l)
                        };
                        var isExsit = false;
                        for(let al of allLinks){
                            var s_id = al.source,
                                d_id = al.target;
                            if((l.source == s_id && l.target==d_id) ||(l.target == s_id && l.source==d_id)){
                                isExsit = true;
                                break;
                            }
                        }
                        if(!isExsit){
                            allLinks.push(l);
                        }
                    }
                }
            }
            allNodes = Object.keys(nodeName).map(d=>{
                return {
                    name:d
                }
            })
            console.log("nodes:",Object.keys(nodeName).length);
            console.log("links:",allLinks.length);
            return {
                nodes:allNodes,
                links:allLinks
            }
        }
    </script>
